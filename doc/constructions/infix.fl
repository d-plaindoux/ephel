--{
    @infix add the capability to have infix function application
    This annotation is used the the type specification

    Left or Right associativity and priority should be targeted.
}--

--{
    Reversed application using @infix everywhere
}--

sig + : @infix Int -> @infix Int -> Int

val main : Int = 1 2 +
--{
    Equivalent to `(1 (2 +))`
}--

-- Trivial and simplistic DSL using infix

sig IfThen : type -> type
val IfThen = A => | ifThen : Bool -> Lazy A -> IfThen A

sig if : {A:type} -> Bool -> Lazy A -> IfThen A
val if = c t => ifThen c t

sig else : {A:type} -> @infix IfThen A -> Lazy A -> A
val else = ifThen b t => e => case b (_ => eval t) (_ => eval e)

val test : Bool -> Int = b => if b { 1 } else { 2 }

-{
    A dedicated pass should be provided in the compiler which
    generates code without infix consideration. In addition this pass
    should manage left and right associativity and also priorities.
}-
