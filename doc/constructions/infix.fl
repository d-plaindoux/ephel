--{
    @infix add the capability to have infix function application
    This annotation is used the the type specification

    Left or Right associativity and priority should be targeted.
}--

--{
    Reversed application using @infix everywhere
}--

sig + : @infix Int -> @infix Int -> Int

val main : Int = 1 2 +
--{
    Equivalent to `(1 (2 +))`
}--

-- Trivial and simplistic DSL using infix

sig IfThen : type -> type
val IfThen = A => | ifThen : Bool -> Lazy A -> IfThen A

sig if : {A:type} -> Bool -> Lazy A -> IfThen A
val if = c t => ifThen c t

sig else : {A:type} -> @infix IfThen A -> Lazy A -> A
val else = ifThen b t => e => case b (_ => eval t) (_ => eval e)

val test : Bool -> Int = b => if b { 1 } else { 2 }

-{
    A dedicated pass should be provided in the compiler which manipulates
    and generates code without infix consideration. In addition this pass
    should manage left or right associativity and also priorities.
}-

-{
    Pseudo object approach with a string separation between data and behavior
}-

sig Vector : sig struct
    sig x : @infix t -> int
    sig y : @infix t -> int
    sig + : @infix Vector -> Vector
end

sig vector : int -> int -> Vector
val vector = x y => val struct
    sig x = x
    sig y = y
    sig + = v => vector (v x + x) (v y + y) -- fold should be used here -> Can we infer it?
end