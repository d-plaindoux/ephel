sig Either : type -> type -> type
val Either = E A =>
    | Left  : E -> Either E A
    | Right : A ->  Either E A

val left : {E A:type} -> E -> Either E A = {_ _} => Left
val right : {E A:type} -> A -> Either E A = {_ _} => Right

val Functor : (E: type) -> category.functor.Functor (Either E) =
    val struct
        val map = f =>
            | Left e  => Left e
            | Right a => Right $ f a

        val Laws =
            val struct
                val ''map id = id'' =
                    | Left _  => refl
                    | Right _ => refl

                val ''(map f) <| (map g) = map (f <| g)'' =
                    | Left _  => refl
                    | Right _ => refl
            end
    end

val Applicative : (E: type) -> category.applicative.Applicative (Either E) =
    val struct
        open Functor

        val pure = some
        val product =
            | Left l  => _ => Left l
            | Right f =>
                | Left l  => Left l
                | Right a => Right (f,a)
    end

val Monad : (E: type) -> category.monad.Monad (Either E) =
    val struct
        open Applicative

        val join =
            | Left l  => Left l
            | Right a => a
   end
