sig _? : type -> type (infix 200)
val _? = A =>
    | None : A?
    | Some : A -> A?

val none : {A:type} -> A? = None
val some : {A:type} -> A -> A? = Some

val Functor : data.Functor _? =
    val struct
        val map = f =>
            | None => None
            | Some a => Some $ f a

        -- Functor laws

        -{
            Note: tactics "Ã  la Coq" are missing here since we
            have to exhibit the term which inhabits the type!
        }-

        val ''map id = id'' =
            | None   => refl
            | Some _ => refl

        val ''(map f) <| (map g) = map (f <| g)'' =
            | None   => refl
            | Some _ => refl
    end

val Applicative : data.Applicative _? =
    val struct
        open Functor

        val pure = some
        val product =
            | None   => _ => None
            | Some f =>
                | None   => None
                | Some a => Some (f,a)
    end

val Monad : data.Monad _? =
    val struct
        open Applicative

        val join =
            | None   => None
            | Some a => a
   end
